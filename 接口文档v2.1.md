# PKI 小型 CA 系统｜前端接口对接文档（Vue）

> 说明：本文档已根据 `UserController / CertificateController / CRLController / OperationLogController` 源码逐项核对，修正了此前 **GET/POST 写错**、路径写错、返回结构写错的问题。
> Base URL：`http://localhost:8080`

---

## 0. 通用约定

- Content-Type：`application/json; charset=utf-8`
- 认证方式：JWT  
  - 请求头：`Authorization: Bearer <token>`
- 统一包装：多数接口返回 `ApiResponse<T>`，但**少数管理接口直接返回 List（非 ApiResponse）**，见下文备注。

### 0.1 ApiResponse 结构（多数接口）

```json
{
  "success": true,
  "message": "ok",
  "data": {}
}
```

| 字段 | 类型 | 说明 |
|---|---|---|
| success | boolean | 是否成功 |
| message | string | 提示信息 |
| data | any | 返回数据（失败时通常为 null） |

---

## 1. 统一错误返回规范（前端必须遵守）

> 说明：业务校验失败通常返回 200 + `success=false`；认证/鉴权失败通常为 401/403（由 Spring Security 产生）。

### 1.1 401 Unauthorized（未登录 / token 无效）
```json
{
  "success": false,
  "message": "未登录或登录已失效",
  "data": null
}
```

### 1.2 403 Forbidden（权限不足）
```json
{
  "success": false,
  "message": "权限不足，无法访问该资源",
  "data": null
}
```

### 1.3 业务错误（逻辑校验失败，200）
```json
{
  "success": false,
  "message": "业务错误说明",
  "data": null
}
```

> 备注：当前后端部分接口在 404 时直接返回空（`ResponseEntity.notFound()`），不是 ApiResponse JSON；该行为如果要统一为 JSON，需要后端新增统一异常处理器（后续可做）。

---

## 2. 权限与接口总览（按 Controller 实现 + 你当前 SecurityConfig 约束）

### 2.1 PermitAll（无需登录）
- `POST /api/users/register`
- `POST /api/users/auth/challenge`
- `POST /api/users/auth/login`
- `GET  /api/certificates/status?serialNumber=...`
- `GET  /api/certificates/{certId}/status`
- `GET  /api/certificates/{serialNumber}/verify`
- `GET  /api/crl`

### 2.2 USER / ADMIN（登录后可访问）
- `GET  /api/certificates`
- `POST /api/certificates/apply`
- `GET  /api/certificates/{certId}/download`
- `POST /api/crl/revoke`

### 2.3 ADMIN only（仅管理员）
- `GET  /api/certificates/requests`
- `POST /api/certificates/requests/{id}/approve`
- `GET  /api/logs`（注意：**返回 List，不是 ApiResponse**）
- `GET  /api/users`（注意：**返回 List，不是 ApiResponse**）

---

## 3. 用户接口（/api/users）

### 3.1 用户注册

**请求**
```
POST /api/users/register
```

**Body**
```json
{
  "username": "Alan",
  "email": "Alan@test.com",
  "publicKey": "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----",
  "role": "ROLE_USER"
}
```

**成功响应（ApiResponse<UserEntity>）**
```json
{
  "success": true,
  "message": "ok",
  "data": {
    "userId": 3,
    "username": "Alan",
    "email": "Alan@test.com",
    "publicKey": "-----BEGIN PUBLIC KEY-----\n...",
    "registerTime": "2025-12-12T19:36:43.647",
    "role": "ROLE_USER"
  }
}
```

**失败响应（示例）**
```json
{ "success": false, "message": "用户名已存在", "data": null }
```

---

### 3.2 获取 Challenge（PKI 登录 Step 1）

> 已按源码核对：该接口为 **POST**，不是 GET。

**请求**
```
POST /api/users/auth/challenge
```

**Body（LoginRequest）**
```json
{
  "username": "Alan"
}
```

**成功响应（ApiResponse<String>）**
```json
{ "success": true, "message": "ok", "data": "a92f5b1e..." }
```

**失败响应（示例）**
```json
{ "success": false, "message": "用户不存在", "data": null }
```

---

### 3.3 PKI 登录（验签 + 返回 JWT）

**请求**
```
POST /api/users/auth/login
```

**Body（LoginVerifyRequest）**
```json
{
  "username": "Alan",
  "challenge": "a92f5b1e...", 
  "signature": "Base64Signature"
}
```

**重要说明（与后端实现一致）**
- 后端实际用于验签的 message 是 **服务端缓存的 challenge**（`challengeService.get(username)`），而不是前端传入的 `challenge` 字段。
- 但前端仍建议传该字段，便于排查与日志对齐。

**成功响应（ApiResponse<String>，data 为 JWT）**
```json
{ "success": true, "message": "ok", "data": "eyJhbGciOi..." }
```

**失败响应（示例）**
```json
{ "success": false, "message": "challenge无效或已过期", "data": null }
```
```json
{ "success": false, "message": "签名验证失败", "data": null }
```

---

### 3.4 查询全部用户（管理员）

**请求**
```
GET /api/users
```

**Header**
```
Authorization: Bearer <ADMIN_JWT>
```

**响应（注意：不是 ApiResponse，是 List<UserEntity>）**
```json
[
  {
    "userId": 1,
    "username": "Alice",
    "email": "alice@example.com",
    "publicKey": "-----BEGIN PUBLIC KEY-----\n...",
    "registerTime": "2025-11-05T19:17:02.803",
    "role": "ROLE_USER"
  }
]
```

---

## 4. 证书接口（/api/certificates）

### 4.1 查询所有证书（登录后）

**请求**
```
GET /api/certificates
```

**Header**
```
Authorization: Bearer <JWT>
```

**响应（ApiResponse<List<CertificateEntity>>）**：略（与实际字段一致即可）

---

### 4.2 旧签发接口（管理员，旧流程）

> 当前 Controller 明确注明：“旧接口不再使用，但为系统稳定不删除”。

**请求**
```
POST /api/certificates/issue?userId=3
```

**Body（CertificateEntity）**
```json
{
  "serialNumber": "SN-20251214-001",
  "certPEM": "-----BEGIN CERTIFICATE-----...",
  "validFrom": "2025-12-14T00:00:00",
  "validTo": "2026-12-14T00:00:00"
}
```

**响应（ApiResponse<CertificateEntity>）**：略

---

### 4.3 按 certId 查询证书状态（公开）

**请求**
```
GET /api/certificates/{certId}/status
```

**响应（ApiResponse<String>）**
```json
{ "success": true, "message": "ok", "data": "有效" }
```

---

### 4.4 按序列号查询证书状态（公开）

**请求**
```
GET /api/certificates/status?serialNumber=SN-20251214-001
```

**响应（ApiResponse<String>）**：同上

---

### 4.5 按序列号验证证书（公开）

**请求**
```
GET /api/certificates/{serialNumber}/verify
```

**成功响应（ApiResponse<Map> 示例）**
```json
{
  "success": true,
  "message": "ok",
  "data": {
    "status": "有效",
    "validFrom": "2025-12-14T00:00:00",
    "validTo": "2026-12-14T00:00:00"
  }
}
```

---

### 4.6 申请证书（登录后）

**请求**
```
POST /api/certificates/apply
```

**Header**
```
Authorization: Bearer <JWT>
```

**Body**
无

**响应（ApiResponse<Long>）**
```json
{ "success": true, "message": "ok", "data": 12 }
```

---

### 4.7 查询待审批申请列表（管理员）

**请求**
```
GET /api/certificates/requests
```

**Header**
```
Authorization: Bearer <ADMIN_JWT>
```

**响应（ApiResponse<List<CertificateRequestEntity>>）**：略

---

### 4.8 审批申请并签发证书（管理员）

> 已按源码核对：路径为 `/requests/{id}/approve`，并且是 **POST**。

**请求**
```
POST /api/certificates/requests/{id}/approve
```

**Header**
```
Authorization: Bearer <ADMIN_JWT>
```

**Body**
无

**成功响应（ApiResponse<Long>，返回 certId）**
```json
{ "success": true, "message": "ok", "data": 5 }
```

**失败响应（示例）**
```json
{ "success": false, "message": "该申请不是待审批状态", "data": null }
```

---

### 4.9 下载证书（登录后，权限受控）

**请求**
```
GET /api/certificates/{certId}/download
```

**Header**
```
Authorization: Bearer <JWT>
```

**成功响应**
- HTTP 200
- Header：`Content-Disposition: attachment; filename=certificate-{certId}.pem`
- Content-Type：`application/x-pem-file`
- Body：证书 PEM 字符串（非 ApiResponse）

**失败响应（当前实现）**
- 证书不存在：HTTP 404（无 JSON body）
- USER 下载他人证书：抛出 `AccessDeniedException` → HTTP 403（是否带 JSON 取决于你是否做了统一异常处理）

---

## 5. CRL 接口（/api/crl）

### 5.1 查询吊销记录（公开）

**请求**
```
GET /api/crl
```

**响应（ApiResponse<List<CRLEntity>>）**：略

---

### 5.2 吊销证书（登录后）

> 已按源码核对：路径为 `/api/crl/revoke`，方法为 **POST**。

**请求**
```
POST /api/crl/revoke
```

**Header**
```
Authorization: Bearer <JWT>
```

**Body（Map payload）**
```json
{
  "certId": 1,
  "reason": "keyCompromise"
}
```

**成功响应（ApiResponse<CRLEntity>）**
```json
{ "success": true, "message": "ok", "data": { "crlid": 1, "reason": "keyCompromise", "revokeTime": "2025-12-14T10:00:00" } }
```

**失败响应（示例）**
```json
{ "success": false, "message": "参数不完整", "data": null }
```
```json
{ "success": false, "message": "证书不存在或已被吊销", "data": null }
```

---

## 6. 操作日志接口（/api/logs，管理员）

### 6.1 查询所有日志

**请求**
```
GET /api/logs
```

**Header**
```
Authorization: Bearer <ADMIN_JWT>
```

**响应（注意：不是 ApiResponse，是 List<OperationLogEntity>）**
```json
[
  {
    "logId": 1,
    "operator": "Alan",
    "action": "申请证书",
    "target": "CertificateRequest",
    "actionTime": "2025-12-14T10:00:00",
    "details": "requestId=12"
  }
]
```

---

## 7. 前端（Vue/Axios）对接建议

- 请求拦截器：自动加 `Authorization`（若 token 存在）
- 响应拦截器：统一处理
  - 401：清 token → 跳登录页
  - 403：提示“权限不足”
  - 200 且 `success=false`：提示 `message`

---

文档版本：v2.1（已按 4 个 Controller 源码逐项校对修正）
